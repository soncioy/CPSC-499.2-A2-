/*
 * This annotated grammar is a heavily modified form of the one produced by
 * Sreenivasa Viswanadha (simplified and enhanced for 1.5) found in the
 * JavaCC grammar repository.  The original copyright notice follows.
 */
/*
 * Copyright Â© 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */
options
{
  BUILD_TOKEN_MANAGER = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  ERROR_REPORTING = false;
  COMMON_TOKEN_ACTION = false;
  STATIC = false;
  DEBUG_TOKEN_MANAGER = false;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(Java12Parser)
package ca.ucalgary.cpsc49902.javacc;
import java.util.*;

public class Java12Parser {

};
PARSER_END(Java12Parser)
/*
 * LINE TERMINATORS
 */
SPECIAL_TOKEN :
{
  "\n"
| "\r"
}

/*
 * WHITE SPACE
 */
SPECIAL_TOKEN :
{
  " "
| "\t"
| "\f"
}

/*
 * COMMENTS
 */
MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| < "/**" ~[ "/" ] >
  {
    input_stream.backup(1);
  }
  : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

< IN_SINGLE_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT :
    "\n"
  | "\r"
  | "\r\n" > : DEFAULT
}

< IN_MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MULTI_LINE_COMMENT : "*/" > : DEFAULT
}

< IN_FORMAL_COMMENT >
SPECIAL_TOKEN :
{
  < FORMAL_COMMENT : "*/" > : DEFAULT
}

< IN_SINGLE_LINE_COMMENT, IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

/*
 * LITERALS
 */

/*
 * INTEGER LITERALS
 */
TOKEN :
{
  < INTEGER_LITERAL :
    < DECIMAL_INTEGER_LITERAL >
  | < HEX_INTEGER_LITERAL >
  | < OCTAL_INTEGER_LITERAL > >
| < #DECIMAL_INTEGER_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* ([ "l", "L" ])? >
| < #HEX_INTEGER_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ ([ "l", "L" ])? >
| < #OCTAL_INTEGER_LITERAL : "0" ([ "0"-"7" ])* ([ "l", "L" ])? >
}

/*
 * FLOATING-POINT LITERALS
 */

TOKEN :
{
  < FLOATING_POINT_LITERAL :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT_PART >)? ([ "f", "F", "d", "D" ])?
  | "." ([ "0"-"9" ])+ (< EXPONENT_PART >)? ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ < EXPONENT_PART > ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ (< EXPONENT_PART >)? [ "f", "F", "d", "D" ] >
| < #EXPONENT_PART : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
}

/*
 * BOOLEAN LITERALS
 */

TOKEN :
{
  < FALSE : "false" >
|
  < TRUE : "true" >
}

/*
 * CHARACTER LITERALS
 */

TOKEN :
{
  < CHARACTER_LITERAL :
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        | ("u")+ [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ]
        )
      )
    )
    "'" >
}

/*
 * STRING LITERALS
 */

TOKEN :
{
  < STRING_LITERAL :
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        | ("u")+ [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ]
        )
      )
    )*
    "\"" >
}

/*
 * NULL LITERALS
 */

TOKEN :
{
  < NULL : "null" >
}

/*
 * SEPARATORS
 */

TOKEN :
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

/*
 * OPERATORS
 */

TOKEN :
{
  < ASSIGN : "=" >
| < LT : "<" >
| < BANG : "!" >
| < TILDE : "~" >
| < HOOK : "?" >
| < COLON : ":" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NE : "!=" >
| < SC_OR : "||" >
| < SC_AND : "&&" >
| < INCR : "++" >
| < DECR : "--" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < BIT_AND : "&" >
| < BIT_OR : "|" >
| < XOR : "^" >
| < REM : "%" >
| < LSHIFT : "<<" >
| < PLUSASSIGN : "+=" >
| < MINUSASSIGN : "-=" >
| < STARASSIGN : "*=" >
| < SLASHASSIGN : "/=" >
| < ANDASSIGN : "&=" >
| < ORASSIGN : "|=" >
| < XORASSIGN : "^=" >
| < REMASSIGN : "%=" >
| < LSHIFTASSIGN : "<<=" >
| < RSIGNEDSHIFTASSIGN : ">>=" >
| < RUNSIGNEDSHIFTASSIGN : ">>>=" >
| < RUNSIGNEDSHIFT : ">>>" >
| < RSIGNEDSHIFT : ">>" >
| < GT : ">" >
}

/*
 * KEYWORDS
 *
 * The keywords must come after all other identifier-like tokens but before identifiers.
 */

TOKEN :
{
  < ABSTRACT : "abstract" >
| < BOOLEAN : "boolean" >
| < BREAK : "break" >
| < BYTE : "byte" >
| < CASE : "case" >
| < CATCH : "catch" >
| < CHAR : "char" >
| < CLASS : "class" >
| < CONST : "const" >
| < CONTINUE : "continue" >
| < _DEFAULT : "default" >
| < DO : "do" >
| < DOUBLE : "double" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FINAL : "final" >
| < FINALLY : "finally" >
| < FLOAT : "float" >
| < FOR : "for" >
| < GOTO : "goto" >
| < IF : "if" >
| < IMPLEMENTS : "implements" >
| < IMPORT : "import" >
| < INSTANCEOF : "instanceof" >
| < INT : "int" >
| < INTERFACE : "interface" >
| < LONG : "long" >
| < NATIVE : "native" >
| < NEW : "new" >
| < PACKAGE : "package" >
| < PRIVATE : "private" >
| < PROTECTED : "protected" >
| < PUBLIC : "public" >
| < RETURN : "return" >
| < SHORT : "short" >
| < STATIC : "static" >
| < SUPER : "super" >
| < SWITCH : "switch" >
| < SYNCHRONIZED : "synchronized" >
| < THIS : "this" >
| < THROW : "throw" >
| < THROWS : "throws" >
| < TRANSIENT : "transient" >
| < TRY : "try" >
| < VOID : "void" >
| < VOLATILE : "volatile" >
| < WHILE : "while" >
| < STRICTFP : "strictfp" >
}


/*
 * IDENTIFIERS
 */

TOKEN :
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "$",
    "A"-"Z",
    "_",
    "a"-"z",
    "\u00c0"-"\u00d6",
    "\u00d8"-"\u00f6",
    "\u00f8"-"\u00ff",
    "\u0100"-"\u1fff",
    "\u3040"-"\u318f",
    "\u3300"-"\u337f",
    "\u3400"-"\u3d2d",
    "\u4e00"-"\u9fff",
    "\uf900"-"\ufaff"
    ]
  >
|
  < #DIGIT :
    [
    "0"-"9",
    "\u0660"-"\u0669",
    "\u06f0"-"\u06f9",
    "\u0966"-"\u096f",
    "\u09e6"-"\u09ef",
    "\u0a66"-"\u0a6f",
    "\u0ae6"-"\u0aef",
    "\u0b66"-"\u0b6f",
    "\u0be7"-"\u0bef",
    "\u0c66"-"\u0c6f",
    "\u0ce6"-"\u0cef",
    "\u0d66"-"\u0d6f",
    "\u0e50"-"\u0e59",
    "\u0ed0"-"\u0ed9",
    "\u1040"-"\u1049"
    ] >
}


/**
* Names, Identifiers and Literals
*/
/* JLS2: Identifier: IDENTIFIER */
void Identifier():
{
}
{
    <IDENTIFIER>
}

/* JLS2: QualifiedIdentifier: Identifier { . Identifier } */
void QualifiedIdentifier():
{
}
{
    Identifier() (<DOT> Identifier() )*
}

/* JLS2: Literal:
 *   IntegerLiteral | FloatingPointLiteral | CharacterLiteral
 * | StringLiteral | BooleanLiteral | NullLiteral
 */
void Literal():
{
}
{
    IntegerLiteral()
    | FloatingPointLiteral()
    | CharacterLiteral()
    | StringLiteral()
    | BooleanLiteral()
    | NullLiteral()
}

/**
* Helpers for literals
*/
void IntegerLiteral():
{
}
{
    <INTEGER_LITERAL>
}

void FloatingPointLiteral():
{
}
{
    <FLOATING_POINT_LITERAL>
}

void CharacterLiteral():
{
}
{
    <CHARACTER_LITERAL>
}

void StringLiteral():
{
}
{
    <STRING_LITERAL>
}

void BooleanLiteral():
{
}
{
    <TRUE> | <FALSE>
}

void NullLiteral():
{
}
{
    <NULL>
}

//we replace QualifierIdentifier with this
void Name():
{
}
{
    <IDENTIFIER> (<DOT> <IDENTIFIER> )*
}
/**
* Below are the production rules based on JLS2 CHAPTER 18 GRAMMAR.
  [X] == [X]
  {X} == (X)*
  word package == <PACKAGE> token
  end of file == <EOF>

  So we convert each and every rule one by one from JLS2 TO JAVACC equivalent
*/

/*
JLS2
CompilationUnit:
[package QualifiedIdentifier ; ] {ImportDeclaration}
{TypeDeclaration}
 */
void CompilationUnit():
{
}
{
    [ PackageDeclaration() ] //optional as not every java file has a package name but this sees package keyword then name and then semicolon
    ( ImportDeclaration() )* //handles import statements
    ( TypeDeclaration() )* //handles multiple classes
    <EOF> //if we see this we have parsed file properly
}

/*
JLS2
[package QualifiedIdentifier ;]
made seperate rule
 */
void PackageDeclaration():
{
}
{
    <PACKAGE> Name() <SEMICOLON> //Name() is like QualifiedIdentifier
}

/*
JLS2
ImportDeclaration:
  import Identifier { . Identifier } [ . * ] ;
 */
void ImportDeclaration():
{
}
{
    <IMPORT> Name() [<DOT><STAR>] <SEMICOLON> //pretty easy to understand this
}

/*
JLS2
TypeDeclaration:
  ClassOrInterfaceDeclaration
| ;
 */
void TypeDeclaration():
{
}
{
    ClassDeclaration() //tells parser to look for class
   |InterfaceDeclaration() //or look for interface declaration
   | <SEMICOLON> //this is null or empty declration as its legal to just have a semicolon
}

/* JLS2: ModifiersOpt: { Modifier } */
void Modifiers():
{
}
{
    (Modifier() )*
}

/* JLS2: Modifier:
 * public | protected | private | static | abstract | final | native |
 * synchronized | transient | volatile | strictfp
 */
void Modifier():
{
}
{
    <PUBLIC> | <STATIC> | <PROTECTED> | <PRIVATE> | <ABSTRACT> | <FINAL>
    | <NATIVE> | <SYNCHRONIZED> | <TRANSIENT> | <VOLATILE> | <STRICTFP>
}

/* JLS2: BasicType:
 * byte | short | char | int | long | float | double | boolean
 */
void PrimitiveType():
{
}
{
    <BYTE> | <SHORT>  | <CHAR> | <INT> | <LONG> | <FLOAT> | <DOUBLE> | <BOOLEAN>
}

/* JLS2: BracketsOpt: { [] } */
void BracketsOpt():
{
}
{
    (<LBRACKET> <RBRACKET> )*
}

//helper array brackets
void ArrayBrackets():
{
}
{
   <LBRACKET> <RBRACKET>
}

/* JLS2: Type:
 *   Identifier { . Identifier } BracketsOpt
 * | BasicType
 * */
void Type():
{
}
{
   PrimitiveType() (ArrayBrackets())*
   |Name() (ArrayBrackets())*
}

void TypeOrVoid():
{
}
{
   <VOID> | Type()
}


//CLASSES AND INTERFACES


/*
JLS2
ClassDeclaration:
  class Identifier [extends Type] [implements TypeList] ClassBody
 */
void ClassDeclaration():
{
    //acts like a variable
    Token nameofclass;
}
{
    Modifiers() //public or static
    <CLASS> nameofclass=<IDENTIFIER> //must see class word and finds the name of class and saves it
    [ <EXTENDS> Name()] //optional matches extends followed by a class name
    [ <IMPLEMENTS> Name() (<COMMA> Name())* ] //matches implements and a comma seperated list
    ClassBody() //handles what's inside the class body and moves to the rules
}

/*
JLS2
ClassBody:
  { {ClassBodyDeclaration} }
 */
void ClassBody():
{
}
{
    <LBRACE> (ClassBodyDeclaration())*  <RBRACE> //container for whatever inside class declarations
}

/*
JLS2
ClassBodyDeclaration:
  ;
| [static] Block
| ModifiersOpt MemberDecl
 */
void ClassBodyDeclaration():
{
}
{
    <SEMICOLON> //allowed to have just a semicolon
    | LOOKAHEAD(2) [<STATIC>] Block() //parser sees static and block as lookahead is 2
    | Modifiers() MemberDeclaration()   //variables or methods
}

/*
InterfaceDeclaration:
  interface Identifier [extends TypeList] InterfaceBody
 */
void InterfaceDeclaration():
{
}
{
    Modifiers()
    <INTERFACE> <IDENTIFIER>
    [<EXTENDS> Name() (<COMMA> Name() )*]
    InterfaceBody()
}

/*
JLS2
InterfaceBody:
  { {InterfaceBodyDeclaration} }
 */
void InterfaceBody():
{
}
{
    <LBRACE> (InterfaceBodyDeclaration() )* <RBRACE>
}

/*
JLS2
InterfaceBodyDeclaration:
  ;
| ModifiersOpt InterfaceMemberDecl
 */
void InterfaceBodyDeclaration():
{
}
{
    <SEMICOLON>
    |Modifiers() MethodHeader() <SEMICOLON>
    |Modifiers() ConstantDeclaration()
    |ClassDeclaration()
    |InterfaceDeclaration()
}


//PARAMETERS


/* JLS2:
 * FormalParameters:
 *   ( [FormalParameter { , FormalParameter}] )
 */
void ParametersList():
{
}
{
   Parameter() (<COMMA> Parameter())*
}

void Parameter():
{
}
{
   Type() <IDENTIFIER> (ArrayBrackets())*
}





/*
MEMBER DECLARATIONS
 */



/*
 * JLS2 MemberDecl:
 *   MethodOrFieldDecl
 * | void Identifier MethodDeclaratorRest
 * | Identifier ConstructorDeclaratorRest
 * | ClassOrInterfaceDeclaration
 */
void MemberDeclaration():
{
}
{
    LOOKAHEAD(ConstructorLookahead()) ConstructorDeclaration()
    | LOOKAHEAD(MethodLookahead()) MethodDeclaration()
    | FieldDeclaration()
}

boolean ConstructorLookahead():
{
}
{
    (<IDENTIFIER> <LPAREN> ) {return true;}
}

boolean MethodLookahead():
{
}
{
    (TypeOrVoid() <IDENTIFIER> <LPAREN> ) {return true;}
}

/* JLS2 ConstructorDeclaratorRest:
 * FormalParameters [throws QualifiedIdentifierList] MethodBody
 */
void ConstructorDeclaration():
{
}
{
    <IDENTIFIER> <LPAREN> [ParametersList()] <RPAREN> //name of constructor with a option list of inputs in center
    [<THROWS> Name() (<COMMA> Name())*] //optional handling of exceptions
    ConstructorBody() //code inside the curly braces
}


void ConstructorBody():
{
}
{
    <LBRACE>
        [ExplicitConstructorInvocation()]
        (BlockStatement())*
    <RBRACE>
}

void ExplicitConstructorInvocation():
{
    Token start;
    Token end;
}
{
    //this or super as mentioned in JLS are part of java syntax
    (<THIS> <LPAREN> [ArgumentList()] <RPAREN> <SEMICOLON>
   | <SUPER> <LPAREN> [ArgumentList()] <RPAREN> <SEMICOLON> )
   { recordInvocation(start, end);}
}

void MethodDeclaration():
{
}
{
    MethodHeader() //label of our method
    MethodBody() //block of code etc after label
}

void MethodHeader():
{
}
{
    TypeOrVoid() <IDENTIFIER> <LPAREN> [ParametersList()] <RPAREN> //return type then name of method
    [<THROWS> Name() (<COMMA> Name())*] //error handling
}

void MethodBody():
{
}
{
    Block() | <SEMICOLON>   //block of code or ends with semicolon
}

void FieldDeclaration():
{
}
{
    Type() VariableDeclarators() <SEMICOLON> //datatype and then variable name followed by semicolon
}

void VariableDeclarators():
{
}
{
    VariableDeclarator() (<COMMA> VariableDeclarator() )* //finds a single declarator and checks if there is a comma followed by other names, as we can have multiple variables in a single lines
}

/* JLS2:
 * VariableDeclarator:
 *   Identifier VariableDeclaratorRest
 * VariableDeclaratorRest:
 *   BracketsOpt [ = VariableInitializer ]
 */
void VariableDeclarator():
{
}
{
    <IDENTIFIER> (ArrayBrackets())* [<ASSIGN> VariableInitializer() ] //name of variable, checks if variable is a array, lastly handles assignment operator
}

void ConstantDeclaration():
{
}
{
    //implicit constants like public static final
    Type() VariableDeclarators() <SEMICOLON>
}

/* JLS2:
 * ArrayInitializer:
 *   { [VariableInitializer {, VariableInitializer} [,]] }
 * VariableInitializer:
 *   ArrayInitializer | Expression
 */
void ArrayInitializer():
{
}
{
    <LBRACE>
        [VariableInitializer() (<COMMA> VariableInitializer())* ]
        [ <COMMA> ]
    <RBRACE>
}

void VariableInitializer():
{
}
{
    Expression()
    |ArrayInitializer()
}


 /*
 Blocks and statements
  */


/* JLS2 Block:
 *   { BlockStatements }
 * BlockStatements:
 *   { BlockStatement }
 */
void Block():
{
}
{
    <LBRACE> (BlockStatement())* <RBRACE>
}

/* JLS2 BlockStatement:
 *   LocalVariableDeclarationStatement
 * | ClassOrInterfaceDeclaration
 * | [Identifier :] Statement
 */
void BlockStatement():
{
}
{
    LOOKAHEAD( (<FINAL>)? Type() <IDENTIFIER> ) LocalVariableDeclarationStatement()
    | Statement()
}

/* JLS2 LocalVariableDeclarationStatement:
 *   [final] Type VariableDeclarators ;
 */
void LocalVariableDeclarationStatement():
{
}
{
    [<FINAL>] Type() VariableDeclarators() <SEMICOLON>
}

/* JLS2 StatementExpression: Expression */
void StatementExpression():
{
}
{
    Expression()
}

void ArgumentList():
{
}
{
    Expression() (<COMMA> Expression())*
}

/* JLS2 ParExpression: ( Expression ) */
void ParExpression():
{
}
{
    <LPAREN> Expression() <RPAREN>
}

/* JLS2 Statement:
 * Block
 * if ParExpression Statement [else Statement]
 * for ( ForInitOpt ; [Expression] ; ForUpdateOpt ) Statement
 * while ParExpression Statement
 * do Statement while ParExpression ;
 * try Block ( Catches | [Catches] finally Block )
 * switch ParExpression { SwitchBlockStatementGroups }
 * synchronized ParExpression Block
 * return [Expression] ;
 * throw Expression ;
 * break [Identifier]
 * continue [Identifier]
 * ;
 * ExpressionStatement
 * Identifier : Statement
 */
void Statement():
{
}
{
    Block()
    | <IF> <LPAREN> Expression() <RPAREN> Statement() [<ELSE> Statement() ]
    | <WHILE> <LPAREN> Expression() <RPAREN> Statement()
    | <DO> Statement() <WHILE> <LPAREN> Expression() <RPAREN> <SEMICOLON>
    | <FOR> <LPAREN> [ForInit()] <SEMICOLON> [Expression()] <SEMICOLON> [ForUpdate()] <RPAREN> Statement()
    | <SWITCH> <LPAREN> Expression() <RPAREN> <LBRACE> (SwitchGroup())* <RBRACE>
    | <TRY> Block()
        ((CatchClause())+ [<FINALLY> Block()]
        | <FINALLY> Block()
        )
    | <RETURN> [Expression()] <SEMICOLON>
    | <THROW> Expression() <SEMICOLON>
    | <BREAK> [<IDENTIFIER>] <SEMICOLON>
    | <CONTINUE> [<IDENTIFIER>] <SEMICOLON>
    | <SYNCHRONIZED> <LPAREN> Expression() <RPAREN> Block()
    | StatementExpression() <SEMICOLON>
    | <SEMICOLON>
}

/* JLS2 ForInit:
 * StatementExpression MoreStatementExpressions
 * | [final] Type VariableDeclarators
 */
void ForInit():
{
}
{
    StatementExpressionList()
    | LocalVariableDeclarationNoSemicolon()
}

void ForUpdate():
{
}
{
    StatementExpressionList()
}

void LocalVariableDeclarationNoSemicolon():
{
}
{
    Type() VariableDeclarators()
}

void StatementExpressionList():
{
}
{
    StatementExpression() (<COMMA> StatementExpression())*
}

/* JLS2 Catches:
 * CatchClause {CatchClause}
 * CatchClause:
 * catch ( FormalParameter ) Block
 * FormalParameter:
 * [final] Type VariableDeclaratorId
 */
void CatchClause():
{
}
{
    <CATCH> <LPAREN> Type() <IDENTIFIER> <RPAREN> Block()
}

/* JLS2 SwitchBlockStatementGroups:
 * { SwitchBlockStatementGroup }
 * SwitchBlockStatementGroup:
 * SwitchLabel BlockStatements
 * SwitchLabel:
 * case ConstantExpression :
 * default :
 */
void SwitchGroup():
{
}
{
    (<CASE> Expression() <COLON> | <_DEFAULT> <COLON> )
    (BlockStatement())*
}



//EXPRESSIONS