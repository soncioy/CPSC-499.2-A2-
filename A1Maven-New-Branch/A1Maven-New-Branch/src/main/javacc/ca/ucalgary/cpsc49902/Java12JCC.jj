/*
 * This annotated grammar is a heavily modified form of the one produced by
 * Sreenivasa Viswanadha (simplified and enhanced for 1.5) found in the
 * JavaCC grammar repository.  The original copyright notice follows.
 */
/*
 * Copyright Â© 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */
options
{
  BUILD_TOKEN_MANAGER = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  ERROR_REPORTING = false;
  COMMON_TOKEN_ACTION = false;
  STATIC = false;
  DEBUG_TOKEN_MANAGER = false;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(Java12Parser)
package ca.ucalgary.cpsc49902.javacc;
import java.util.*;

public class Java12Parser {

};
PARSER_END(Java12Parser)
/*
 * LINE TERMINATORS
 */
SPECIAL_TOKEN :
{
  "\n"
| "\r"
}

/*
 * WHITE SPACE
 */
SPECIAL_TOKEN :
{
  " "
| "\t"
| "\f"
}

/*
 * COMMENTS
 */
MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| < "/**" ~[ "/" ] >
  {
    input_stream.backup(1);
  }
  : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

< IN_SINGLE_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT :
    "\n"
  | "\r"
  | "\r\n" > : DEFAULT
}

< IN_MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MULTI_LINE_COMMENT : "*/" > : DEFAULT
}

< IN_FORMAL_COMMENT >
SPECIAL_TOKEN :
{
  < FORMAL_COMMENT : "*/" > : DEFAULT
}

< IN_SINGLE_LINE_COMMENT, IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

/*
 * LITERALS
 */

/*
 * INTEGER LITERALS
 */
TOKEN :
{
  < INTEGER_LITERAL :
    < DECIMAL_INTEGER_LITERAL >
  | < HEX_INTEGER_LITERAL >
  | < OCTAL_INTEGER_LITERAL > >
| < #DECIMAL_INTEGER_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* ([ "l", "L" ])? >
| < #HEX_INTEGER_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ ([ "l", "L" ])? >
| < #OCTAL_INTEGER_LITERAL : "0" ([ "0"-"7" ])* ([ "l", "L" ])? >
}

/*
 * FLOATING-POINT LITERALS
 */

TOKEN :
{
  < FLOATING_POINT_LITERAL :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT_PART >)? ([ "f", "F", "d", "D" ])?
  | "." ([ "0"-"9" ])+ (< EXPONENT_PART >)? ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ < EXPONENT_PART > ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ (< EXPONENT_PART >)? [ "f", "F", "d", "D" ] >
| < #EXPONENT_PART : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
}

/*
 * BOOLEAN LITERALS
 */

TOKEN :
{
  < FALSE : "false" >
|
  < TRUE : "true" >
}

/*
 * CHARACTER LITERALS
 */

TOKEN :
{
  < CHARACTER_LITERAL :
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        | ("u")+ [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ]
        )
      )
    )
    "'" >
}

/*
 * STRING LITERALS
 */

TOKEN :
{
  < STRING_LITERAL :
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        | ("u")+ [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ]
        )
      )
    )*
    "\"" >
}

/*
 * NULL LITERALS
 */

TOKEN :
{
  < NULL : "null" >
}

/*
 * SEPARATORS
 */

TOKEN :
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

/*
 * OPERATORS
 */

TOKEN :
{
  < ASSIGN : "=" >
| < LT : "<" >
| < BANG : "!" >
| < TILDE : "~" >
| < HOOK : "?" >
| < COLON : ":" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NE : "!=" >
| < SC_OR : "||" >
| < SC_AND : "&&" >
| < INCR : "++" >
| < DECR : "--" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < BIT_AND : "&" >
| < BIT_OR : "|" >
| < XOR : "^" >
| < REM : "%" >
| < LSHIFT : "<<" >
| < PLUSASSIGN : "+=" >
| < MINUSASSIGN : "-=" >
| < STARASSIGN : "*=" >
| < SLASHASSIGN : "/=" >
| < ANDASSIGN : "&=" >
| < ORASSIGN : "|=" >
| < XORASSIGN : "^=" >
| < REMASSIGN : "%=" >
| < LSHIFTASSIGN : "<<=" >
| < RSIGNEDSHIFTASSIGN : ">>=" >
| < RUNSIGNEDSHIFTASSIGN : ">>>=" >
| < RUNSIGNEDSHIFT : ">>>" >
| < RSIGNEDSHIFT : ">>" >
| < GT : ">" >
}

/*
 * KEYWORDS
 *
 * The keywords must come after all other identifier-like tokens but before identifiers.
 */

TOKEN :
{
  < ABSTRACT : "abstract" >
| < BOOLEAN : "boolean" >
| < BREAK : "break" >
| < BYTE : "byte" >
| < CASE : "case" >
| < CATCH : "catch" >
| < CHAR : "char" >
| < CLASS : "class" >
| < CONST : "const" >
| < CONTINUE : "continue" >
| < _DEFAULT : "default" >
| < DO : "do" >
| < DOUBLE : "double" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FINAL : "final" >
| < FINALLY : "finally" >
| < FLOAT : "float" >
| < FOR : "for" >
| < GOTO : "goto" >
| < IF : "if" >
| < IMPLEMENTS : "implements" >
| < IMPORT : "import" >
| < INSTANCEOF : "instanceof" >
| < INT : "int" >
| < INTERFACE : "interface" >
| < LONG : "long" >
| < NATIVE : "native" >
| < NEW : "new" >
| < PACKAGE : "package" >
| < PRIVATE : "private" >
| < PROTECTED : "protected" >
| < PUBLIC : "public" >
| < RETURN : "return" >
| < SHORT : "short" >
| < STATIC : "static" >
| < SUPER : "super" >
| < SWITCH : "switch" >
| < SYNCHRONIZED : "synchronized" >
| < THIS : "this" >
| < THROW : "throw" >
| < THROWS : "throws" >
| < TRANSIENT : "transient" >
| < TRY : "try" >
| < VOID : "void" >
| < VOLATILE : "volatile" >
| < WHILE : "while" >
| < STRICTFP : "strictfp" >
}


/*
 * IDENTIFIERS
 */

TOKEN :
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "$",
    "A"-"Z",
    "_",
    "a"-"z",
    "\u00c0"-"\u00d6",
    "\u00d8"-"\u00f6",
    "\u00f8"-"\u00ff",
    "\u0100"-"\u1fff",
    "\u3040"-"\u318f",
    "\u3300"-"\u337f",
    "\u3400"-"\u3d2d",
    "\u4e00"-"\u9fff",
    "\uf900"-"\ufaff"
    ]
  >
|
  < #DIGIT :
    [
    "0"-"9",
    "\u0660"-"\u0669",
    "\u06f0"-"\u06f9",
    "\u0966"-"\u096f",
    "\u09e6"-"\u09ef",
    "\u0a66"-"\u0a6f",
    "\u0ae6"-"\u0aef",
    "\u0b66"-"\u0b6f",
    "\u0be7"-"\u0bef",
    "\u0c66"-"\u0c6f",
    "\u0ce6"-"\u0cef",
    "\u0d66"-"\u0d6f",
    "\u0e50"-"\u0e59",
    "\u0ed0"-"\u0ed9",
    "\u1040"-"\u1049"
    ] >
}

/**
* Below are the production rules based on the tokens above
*/
void CompilationUnit():
{}
{
    [ <PACKAGE> Name() <SEMICOLON> ] //optional as not every java file has a package name but this sees package keyword then name and then semicolon
    ( <IMPORT> Name() [ <DOT> <STAR> ] <SEMICOLON> )* //handles import statements
    ( TypeDeclaration() )* //handles multiple classes
    <EOF> //if we see this we have parsed file properly
}

void TypeDeclaration():
{}
{
    ClassDeclaration() //tells parser to look for class
   |InterfaceDeclaration() //or look for interface declaration
   | <SEMICOLON> //this is null or empty declration as its legal to just have a semicolon
}

void ClassDeclaration():
{
    //acts like a variable
    Token nameofclass;
}
{
    Modifiers() //public or static
    <CLASS> nameofclass=<IDENTIFIER> //must see class word and finds the name of class and saves it
    [ <EXTENDS> Name()] //optional but you can inherit from another class
    [ <IMPLEMENTS> Name() (<COMMA> Name())* ] //optional handles list of interfaces
    ClassBody() //checks whats inside the class body and moves to the rules
}

void InterfaceDeclaration():
{}
{
    Modifiers() //public or static etc
    <INTERFACE> <IDENTIFIER> //must see identifier keyword
    [ <EXTENDS> Name() (<COMMA> Name())* ] //interface can extends multiple things
    InterfaceBody() //checks whats inside interface body
}

void ClassBody():
{}
{
    <LBRACE> (ClassBodyDeclaration())*  <RBRACE> //container for whatever inside class declarations
}

void InterfaceBody():
{}
{
    <LBRACE> (InterfaceBodyDeclaration())* <RBRACE> //container for whatever inside interface declarations
}

void ClassBodyDeclaration():
{}
{
    <SEMICOLON> //allowed to have just a semicolon
    | Modifiers() MemberDeclaration()   //variables or methods
    | ClassDeclaration() //nested class declration
    | InterfaceDeclaration() //nested interface declaration
}

void InterfaceBodyDeclaration():
{}
{
    <SEMICOLON> //allowed to have just a semicolon
    |Modifiers() MethodHeader() <SEMICOLON> //interfaces don't have code blocks for methods and end with semicolon
}

/*
Method Declarations and using Lookahead where needed
 */

void MemberDeclaration():
{}
{
    LOOKAHEAD(ConstructorLookahead()) ConstructorDeclaration() //tests to know if it is a constructor
    | LOOKAHEAD(MethodLookahead()) MethodDeclaration() //if not is it a method
    | FieldDeclaration()//default like int weight;
}

boolean ConstructorLookahead():
{}
{
    (<IDENTIFIER> <LPAREN> ) {return true;} //constructors have same name as java classes followed by parenthesis here we only check left one
}

boolean MethodLookahead():
{}
{
    (Type() <IDENTIFIER> <LPAREN> ) {return true;} //methods have return types then identifier and left parenthesis
}

void ConstructorDeclaration():
{}
{
    <IDENTIFIER> <LPAREN> [ParametersList()] <RPAREN> //name of constructor with a option list of inputs in center
    [<THROWS> Name() (<COMMA> Name())*] //optional handling of exceptions
    Block() //code inside the curly braces
}

void MethodDeclaration():
{}
{
    MethodHeader() //label of our method
    MethodBody() //block of code etc after label
}

void MethodHeader():
{}
{
    TypeOrVoid() <IDENTIFIER> <LPAREN> [ParametersList()] <RPAREN> //return type then name of method
    [<THROWS> Name() (<COMMA> Name())*] //error handling
}

void MethodBody():
{}
{
    Block() | <SEMICOLON>   //block of code or ends with semicolon
}

void FieldDeclaration():
{}
{
    Type() VariableDeclarators() <SEMICOLON> //datatype and then variable name followed by semicolon
}

void VariableDeclarators():
{}
{
    VariableDeclarator() (<COMMA> VariableDeclarators() )* //finds a single declarator and checks if there is a comma followed by other names, as we can have multiple variables in a single lines
}

void VariableDeclarator():
{}
{
    <IDENTIFIER> (ArrayBrackets())* [<ASSIGN> Expression()] //name of variable, checks if variable is a array, lastly handles assignment operator
}