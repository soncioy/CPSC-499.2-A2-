/*
 * This annotated grammar is a heavily modified form of the one produced by
 * Sreenivasa Viswanadha (simplified and enhanced for 1.5) found in the
 * JavaCC grammar repository.  The original copyright notice follows.
 */
/*
 * Copyright Â© 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * California 95054, U.S.A. All rights reserved.  Sun Microsystems, Inc. has
 * intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation,
 * these intellectual property rights may include one or more of the U.S.
 * patents listed at http://www.sun.com/patents and one or more additional
 * patents or pending patent applications in the U.S. and in other countries.
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.  Use is subject to license terms.
 * Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.  This
 * product is covered and controlled by U.S. Export Control laws and may be
 * subject to the export or import laws in other countries.  Nuclear, missile,
 * chemical biological weapons or nuclear maritime end uses or end users,
 * whether direct or indirect, are strictly prohibited.  Export or reexport
 * to countries subject to U.S. embargo or to entities identified on U.S.
 * export exclusion lists, including, but not limited to, the denied persons
 * and specially designated nationals lists is strictly prohibited.
 */
options {
  BUILD_TOKEN_MANAGER = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  ERROR_REPORTING = false;
  COMMON_TOKEN_ACTION = false;
  STATIC = false;
  DEBUG_TOKEN_MANAGER = false;
  DEBUG_PARSER = false;
  TRACK_TOKENS = true;
  MULTI = true;
  VISITOR = true;
}

PARSER_BEGIN(Java12Parser)

package ca.ucalgary.cpsc49902.javacc;

import java.util.*;

public class Java12Parser {
    public static void resetInvocations() {
        // MethodVisitor collects this data, this can be empty
    }

    public static void setFileName(String name) {
        // MethodVisitor collects this data, this can be empty
    }
};

PARSER_END(Java12Parser)

/*
* LINE TERMINATORS
*/
SPECIAL_TOKEN :
{
  "\n"
| "\r"
}

/*
* WHITE SPACE
*/
SPECIAL_TOKEN :
{
  " "
| "\t"
| "\f"
}

/*
* COMMENTS
*/
SPECIAL_TOKEN :
{
    <SINGLE_LINE_COMMENT : "//" (~["\n","\r"])*>
}

MORE :
{
 < "/**" ~[ "/" ] > { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

/*
< IN_SINGLE_LINE_COMMENT >
MORE :
{
  < ~["\n","\r"] >
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
    "\r\n" : DEFAULT
    | "\n" : DEFAULT
    | "\r" : DEFAULT
}

<*>
TOKEN :
{
    <EOF>
} */

< IN_MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MULTI_LINE_COMMENT : "*/" > : DEFAULT
}

< IN_FORMAL_COMMENT >
SPECIAL_TOKEN :
{
  < FORMAL_COMMENT : "*/" > : DEFAULT
}

< IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

/*
* LITERALS
*/

/*
* INTEGER LITERALS
*/
TOKEN :
{
  < INTEGER_LITERAL :
    < DECIMAL_INTEGER_LITERAL >
  | < HEX_INTEGER_LITERAL >
  | < OCTAL_INTEGER_LITERAL > >
| < #DECIMAL_INTEGER_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* ([ "l", "L" ])? >
| < #HEX_INTEGER_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ ([ "l", "L" ])? >
| < #OCTAL_INTEGER_LITERAL : "0" ([ "0"-"7" ])* ([ "l", "L" ])? >
}

/*
* FLOATING-POINT LITERALS
*/
TOKEN :
{
  < FLOATING_POINT_LITERAL :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT_PART >)? ([ "f", "F", "d", "D" ])?
  | "." ([ "0"-"9" ])+ (< EXPONENT_PART >)? ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ < EXPONENT_PART > ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ (< EXPONENT_PART >)? [ "f", "F", "d", "D" ] >
| < #EXPONENT_PART : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
}

/*
* BOOLEAN LITERALS
*/
TOKEN :
{
  < FALSE : "false" >
| < TRUE : "true" >
}

/*
* CHARACTER LITERALS
*/
TOKEN :
{
  < CHARACTER_LITERAL :
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        | ("u")+ [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ]
        )
      )
    )
    "'" >
}

/*
* STRING LITERALS
*/
TOKEN :
{
  < STRING_LITERAL :
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        | ("u")+ [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ] [ "0"-"9", "a"-"f", "A"-"F" ]
        )
      )
    )*
    "\"" >
}

/*
* NULL LITERALS
*/
TOKEN :
{
  < NULL : "null" >
}

/*
* SEPARATORS
*/
TOKEN :
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

/*
* OPERATORS
*/
TOKEN :
{
  < ASSIGN : "=" >
| < LT : "<" >
| < BANG : "!" >
| < TILDE : "~" >
| < HOOK : "?" >
| < COLON : ":" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NE : "!=" >
| < SC_OR : "||" >
| < SC_AND : "&&" >
| < INCR : "++" >
| < DECR : "--" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < BIT_AND : "&" >
| < BIT_OR : "|" >
| < XOR : "^" >
| < REM : "%" >
| < LSHIFT : "<<" >
| < PLUSASSIGN : "+=" >
| < MINUSASSIGN : "-=" >
| < STARASSIGN : "*=" >
| < SLASHASSIGN : "/=" >
| < ANDASSIGN : "&=" >
| < ORASSIGN : "|=" >
| < XORASSIGN : "^=" >
| < REMASSIGN : "%=" >
| < LSHIFTASSIGN : "<<=" >
| < RSIGNEDSHIFTASSIGN : ">>=" >
| < RUNSIGNEDSHIFTASSIGN : ">>>=" >
| < RUNSIGNEDSHIFT : ">>>" >
| < RSIGNEDSHIFT : ">>" >
| < GT : ">" >
}

/*
* KEYWORDS
*/
TOKEN :
{
  < ABSTRACT : "abstract" >
| < BOOLEAN : "boolean" >
| < BREAK : "break" >
| < BYTE : "byte" >
| < CASE : "case" >
| < CATCH : "catch" >
| < CHAR : "char" >
| < CLASS : "class" >
| < CONST : "const" >
| < CONTINUE : "continue" >
| < _DEFAULT : "default" >
| < DO : "do" >
| < DOUBLE : "double" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FINAL : "final" >
| < FINALLY : "finally" >
| < FLOAT : "float" >
| < FOR : "for" >
| < GOTO : "goto" >
| < IF : "if" >
| < IMPLEMENTS : "implements" >
| < IMPORT : "import" >
| < INSTANCEOF : "instanceof" >
| < INT : "int" >
| < INTERFACE : "interface" >
| < LONG : "long" >
| < NATIVE : "native" >
| < NEW : "new" >
| < PACKAGE : "package" >
| < PRIVATE : "private" >
| < PROTECTED : "protected" >
| < PUBLIC : "public" >
| < RETURN : "return" >
| < SHORT : "short" >
| < STATIC : "static" >
| < SUPER : "super" >
| < SWITCH : "switch" >
| < SYNCHRONIZED : "synchronized" >
| < THIS : "this" >
| < THROW : "throw" >
| < THROWS : "throws" >
| < TRANSIENT : "transient" >
| < TRY : "try" >
| < VOID : "void" >
| < VOLATILE : "volatile" >
| < WHILE : "while" >
| < STRICTFP : "strictfp" >
}


/*
* IDENTIFIERS
*/
TOKEN :
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "$",
    "A"-"Z",
    "_",
    "a"-"z",
    "\u00c0"-"\u00d6",
    "\u00d8"-"\u00f6",
    "\u00f8"-"\u00ff",
    "\u0100"-"\u1fff",
    "\u3040"-"\u318f",
    "\u3300"-"\u337f",
    "\u3400"-"\u3d2d",
    "\u4e00"-"\u9fff",
    "\uf900"-"\ufaff"
    ]
  >
|
  < #DIGIT :
    [
    "0"-"9",
    "\u0660"-"\u0669",
    "\u06f0"-"\u06f9",
    "\u0966"-"\u096f",
    "\u09e6"-"\u09ef",
    "\u0a66"-"\u0a6f",
    "\u0ae6"-"\u0aef",
    "\u0b66"-"\u0b6f",
    "\u0be7"-"\u0bef",
    "\u0c66"-"\u0c6f",
    "\u0ce6"-"\u0cef",
    "\u0d66"-"\u0d6f",
    "\u0e50"-"\u0e59",
    "\u0ed0"-"\u0ed9",
    "\u1040"-"\u1049"
    ] >
}

Node CompilationUnit() : {}
{
  [ PackageDeclaration() ]
  ( ImportDeclaration() )*
  (
    LOOKAHEAD( (Modifier())* ( <CLASS> | <INTERFACE> ) )
    TypeDeclaration()
    |
    <SEMICOLON>
  )*
  <EOF>
  { return jjtThis; }
}
/* NAMES & IDENTIFIERS */
void Identifier(): {} { <IDENTIFIER> }
void QualifiedIdentifier(): {} { <IDENTIFIER> ( LOOKAHEAD(2) <DOT> <IDENTIFIER> )* }
void Literal(): {} { <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> | <CHARACTER_LITERAL> | <STRING_LITERAL> | <TRUE> | <FALSE> | <NULL> }

/* TYPES */
void Type(): {}
{
  ( LOOKAHEAD(2) BasicType() | <IDENTIFIER> ( <DOT> <IDENTIFIER> )* ) BracketsOpt()
}
void BasicType(): {} { <BYTE> | <SHORT> | <CHAR> | <INT> | <LONG> | <FLOAT> | <DOUBLE> | <BOOLEAN> }
void BracketsOpt(): {} { ( <LBRACKET> <RBRACKET> )* }
void TypeList(): {} { Type() ( <COMMA> Type() )* }
void QualifiedIdentifierList(): {} { QualifiedIdentifier() ( <COMMA> QualifiedIdentifier() )* }

/* MODIFIERS */
void ModifiersOpt(): {} { ( Modifier() )* }
void Modifier(): {} { <PUBLIC> | <PROTECTED> | <PRIVATE> | <STATIC> | <ABSTRACT> | <FINAL> | <NATIVE> | <SYNCHRONIZED> | <TRANSIENT> | <VOLATILE> | <STRICTFP> }

void PackageDeclaration(): {} { <PACKAGE> QualifiedIdentifier() <SEMICOLON> }
void ImportDeclaration(): {} { <IMPORT> <IDENTIFIER> ( <DOT> <IDENTIFIER> )* [ <DOT> <STAR> ] <SEMICOLON> }

void TypeDeclaration() : {}
{
  LOOKAHEAD( (Modifier())* <CLASS> ) ClassDeclaration()
| InterfaceDeclaration()
}

/* CLASS & INTERFACE DECLARATIONS */
void ClassDeclaration(): {} { ModifiersOpt() <CLASS> <IDENTIFIER> [ <EXTENDS> Type() ] [ <IMPLEMENTS> TypeList() ] ClassBody() }
void ClassBody(): {} { <LBRACE> ( ClassBodyDeclaration() )* <RBRACE> }
void ClassBodyDeclaration(): {} { LOOKAHEAD(2) <STATIC> Block() | LOOKAHEAD(2) Block() | ModifiersOpt() MemberDecl() | <SEMICOLON> }
void InterfaceDeclaration(): {} { ModifiersOpt() <INTERFACE> <IDENTIFIER> [ <EXTENDS> TypeList() ] InterfaceBody() }
void InterfaceBody(): {} { <LBRACE> ( InterfaceBodyDeclaration() )* <RBRACE> }
void InterfaceBodyDeclaration(): {} { LOOKAHEAD( ModifiersOpt() <INTERFACE> ) ClassOrInterfaceDeclaration() | LOOKAHEAD( ModifiersOpt() <CLASS> ) ClassOrInterfaceDeclaration() | LOOKAHEAD( ModifiersOpt() Type() <IDENTIFIER> <LPAREN> ) MethodDeclaration() | FieldDeclaration() | <SEMICOLON> }
void ClassOrInterfaceDeclaration(): {} { ModifiersOpt() ( ClassDeclaration() | InterfaceDeclaration() ) }

/* MEMBERS */
void MemberDecl(): {} { LOOKAHEAD( Type() <IDENTIFIER> <LPAREN> ) MethodDeclaration() | LOOKAHEAD( <VOID> ) MethodDeclaration() | LOOKAHEAD( <IDENTIFIER> <LPAREN> ) ConstructorDeclaration() | FieldDeclaration() | ClassOrInterfaceDeclaration() }
void MethodDeclaration(): {} { ( Type() | <VOID> ) <IDENTIFIER> <LPAREN> [ ParametersList() ] <RPAREN> BracketsOpt() [ <THROWS> QualifiedIdentifierList() ] ( Block() | <SEMICOLON> ) }
void ConstructorDeclaration(): {} { <IDENTIFIER> <LPAREN> [ ParametersList() ] <RPAREN> [ <THROWS> QualifiedIdentifierList() ] <LBRACE> [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ] ( BlockStatement() )* <RBRACE> }
void ExplicitConstructorInvocation(): {} { ( <THIS> | <SUPER> ) Arguments() <SEMICOLON> }
void FieldDeclaration(): {} { Type() VariableDeclarators() <SEMICOLON> }
void VariableDeclarators(): {} { VariableDeclarator() ( <COMMA> VariableDeclarator() )* }
void VariableDeclarator(): {} { <IDENTIFIER> BracketsOpt() [ <ASSIGN> VariableInitializer() ] }
void VariableInitializer(): {} { ArrayInitializer() | Expression() }
void ArrayInitializer(): {} { <LBRACE> [ VariableInitializer() ( LOOKAHEAD(2) <COMMA> VariableInitializer() )* [ <COMMA> ] ] <RBRACE> }
void ParametersList(): {} { FormalParameter() ( <COMMA> FormalParameter() )* }
void FormalParameter(): {} { [ <FINAL> ] Type() <IDENTIFIER> BracketsOpt() }

/* STATEMENTS */
void Block(): {} { <LBRACE> ( BlockStatement() )* <RBRACE> }
void BlockStatement(): {} { LOOKAHEAD( [ <FINAL> ] Type() <IDENTIFIER> ) LocalVariableDeclarationStatement() | LOOKAHEAD(2) ClassOrInterfaceDeclaration() | [ LOOKAHEAD(2) <IDENTIFIER> <COLON> ] Statement() }
void LocalVariableDeclarationStatement(): {} { [ <FINAL> ] Type() VariableDeclarators() <SEMICOLON> }
void Statement(): {} { Block() | <IF> ParExpression() Statement() [ LOOKAHEAD(1) <ELSE> Statement() ] | <FOR> <LPAREN> [ ForInit() ] <SEMICOLON> [ Expression() ] <SEMICOLON> [ ForUpdate() ] <RPAREN> Statement() | <WHILE> ParExpression() Statement() | <DO> Statement() <WHILE> ParExpression() <SEMICOLON> | <TRY> Block() ( ( CatchClause() )+ [ <FINALLY> Block() ] | <FINALLY> Block() ) | <SWITCH> ParExpression() <LBRACE> ( SwitchBlockStatementGroup() )* <RBRACE> | <SYNCHRONIZED> ParExpression() Block() | <RETURN> [ Expression() ] <SEMICOLON> | <THROW> Expression() <SEMICOLON> | <BREAK> [ <IDENTIFIER> ] <SEMICOLON> | <CONTINUE> [ <IDENTIFIER> ] <SEMICOLON> | <SEMICOLON> | Expression() <SEMICOLON> }
void ParExpression(): {} { <LPAREN> Expression() <RPAREN> }
void ForInit(): {} { LOOKAHEAD( [ <FINAL> ] Type() <IDENTIFIER> ) LocalVariableDeclarationStatement() | Expression() ( <COMMA> Expression() )* }
void ForUpdate(): {} { Expression() ( <COMMA> Expression() )* }
void CatchClause(): {} { <CATCH> <LPAREN> FormalParameter() <RPAREN> Block() }
void SwitchBlockStatementGroup(): {} { ( <CASE> Expression() <COLON> | <_DEFAULT> <COLON> ) ( BlockStatement() )* }

/* EXPRESSIONS */
void Expression() : {} { ConditionalExpression() [ AssignmentOperator() Expression() ] }
void AssignmentOperator() : {} { <ASSIGN> | <PLUSASSIGN> | <MINUSASSIGN> | <STARASSIGN> | <SLASHASSIGN> | <ANDASSIGN> | <ORASSIGN> | <XORASSIGN> | <REMASSIGN> | <LSHIFTASSIGN> | <RSIGNEDSHIFTASSIGN> | <RUNSIGNEDSHIFTASSIGN> }
void ConditionalExpression() : {} { ConditionalOrExpression() [ <HOOK> Expression() <COLON> ConditionalExpression() ] }
void ConditionalOrExpression() : {} { ConditionalAndExpression() ( <SC_OR> ConditionalAndExpression() )* }
void ConditionalAndExpression() : {} { InclusiveOrExpression() ( <SC_AND> InclusiveOrExpression() )* }
void InclusiveOrExpression() : {} { ExclusiveOrExpression() ( <BIT_OR> ExclusiveOrExpression() )* }
void ExclusiveOrExpression() : {} { AndExpression() ( <XOR> AndExpression() )* }
void AndExpression() : {} { EqualityExpression() ( <BIT_AND> EqualityExpression() )* }
void EqualityExpression() : {} { InstanceOfExpression() ( ( <EQ> | <NE> ) InstanceOfExpression() )* }
void InstanceOfExpression() : {} { RelationalExpression() [ <INSTANCEOF> Type() ] }
void RelationalExpression() : {} { ShiftExpression() ( ( <LT> | <GT> | <LE> | <GE> ) ShiftExpression() )* }
void ShiftExpression() : {} { AdditiveExpression() ( ( <LSHIFT> | <RSIGNEDSHIFT> | <RUNSIGNEDSHIFT> ) AdditiveExpression() )* }
void AdditiveExpression() : {} { MultiplicativeExpression() ( ( <PLUS> | <MINUS> ) MultiplicativeExpression() )* }
void MultiplicativeExpression() : {} { UnaryExpression() ( ( <STAR> | <SLASH> | <REM> ) UnaryExpression() )* }
void UnaryExpression() : {} { ( <PLUS> | <MINUS> ) UnaryExpression() | PreIncrementExpression() | PreDecrementExpression() | UnaryExpressionNotPlusMinus() }
void PreIncrementExpression() : {} { <INCR> PrimaryExpression() }
void PreDecrementExpression() : {} { <DECR> PrimaryExpression() }
void UnaryExpressionNotPlusMinus() : {} { ( <BANG> | <TILDE> ) UnaryExpression() | LOOKAHEAD( "(" Type() ")" ) CastExpression() | PostfixExpression() }
void CastExpression() : {} { <LPAREN> Type() <RPAREN> UnaryExpression() }
void PostfixExpression() : {} { PrimaryExpression() [ <INCR> | <DECR> ] }
void PrimaryExpression() : {} { PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )* }

void PrimaryPrefix() : {}
{
  Literal()
| <THIS>
| <SUPER> <DOT> <IDENTIFIER>
| <LPAREN> Expression() <RPAREN>
| AllocationExpression()
| LOOKAHEAD( ResultType() <DOT> <CLASS> ) ResultType() <DOT> <CLASS>
| QualifiedIdentifier()
}

void PrimarySuffix() : {}
{
  LOOKAHEAD(2) <DOT> <THIS>
| LOOKAHEAD(2) <DOT> <SUPER>
| LOOKAHEAD(2) <DOT> AllocationExpression()
| <LBRACKET> Expression() <RBRACKET>
| <DOT> <IDENTIFIER>
| MethodInvocation() //replaced Arguments() with MethodInvocation() for jjtree
}

void MethodInvocation() : {} { Arguments() }

void ResultType() : {} { <VOID> | Type() }

// Added #Arguments tag to generate ASTArguments.java
void Arguments() #Arguments : {}
{
  <LPAREN> [ Expression() ( <COMMA> Expression() )* ] <RPAREN>
}

// Added #AllocationExpression tag
void AllocationExpression() #AllocationExpression : {}
{
  <NEW>
  (
    LOOKAHEAD(2) BasicType() ArrayDimsAndInits()
  | QualifiedIdentifier() ( Arguments() [ ClassBody() ] | ArrayDimsAndInits() )
  )
}

// Added missing rule ArrayDimsAndInits
void ArrayDimsAndInits() : {}
{
  LOOKAHEAD(2) ( <LBRACKET> Expression() <RBRACKET> )+ ( LOOKAHEAD(2) <LBRACKET> <RBRACKET> )*
| ( <LBRACKET> <RBRACKET> )+ ArrayInitializer()
}